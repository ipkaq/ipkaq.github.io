{"meta":{"title":"ipkaq's blog","subtitle":null,"description":"皮卡丘的博客","author":"ipkaq","url":"https://ipkaq.com","root":"/"},"pages":[{"title":"about","date":"2019-07-12T02:21:28.000Z","updated":"2019-07-12T04:36:27.000Z","comments":true,"path":"about/index.html","permalink":"https://ipkaq.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-07-12T02:21:23.000Z","updated":"2019-07-12T04:32:19.000Z","comments":true,"path":"categories/index.html","permalink":"https://ipkaq.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-12T02:21:16.000Z","updated":"2019-07-12T04:25:16.000Z","comments":true,"path":"tags/index.html","permalink":"https://ipkaq.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"IT这行是门文科","slug":"计算机这行是门文科","date":"2020-03-26T12:05:07.000Z","updated":"2020-03-27T03:26:33.362Z","comments":true,"path":"2020/03/26/计算机这行是门文科/","link":"","permalink":"https://ipkaq.com/2020/03/26/计算机这行是门文科/","excerpt":"","text":"IT这行是门文科 说这么个观点，肯定会有很多骂我，说这么多计算科学家，这么多数学理论在计算机这行里，你TM说这是文科？说这话是民科？ 首先，我不否认IT这行里，计算机的理论中，存在大量的科学理论，数学理论，并且实现的很好，的确有点工程学的意思，像个工科，而PTL和数据库等领域的研究，又的确是科学。但是，我说的不是计算机上层学院派的高屋建瓴，我说的是中国IT这行，这就好比我说古人寿命普遍比较短寿，你非要跟我说乾隆搞得百叟宴，我还能说啥？更何况，文科和理科的界限在工业界本来就不明显，甚至连学术界，现在也存在大量学科融合的现象，这也是大趋势。但趋势和融合改变不了IT是门文科的事实。 IT这行所有的东西都是人为设计的。你见过哪个自然科学是人设计出来的，不是人发现的？1+1=2是人设计出来的？数学和物理这些硬科学都是自然科学，都是大自然的本质，人类只是发现了他们而已。而IT这行，连冯诺依曼体系，都是设计出来的，从CPU，内存，网络，硬件和软件的方方面面，都是人为设计。 《笑傲江湖》里说，有人的地方就有恩怨，就有江湖。由与是人设计的东西，所以设计本身就会存在品味和偏好问题，这就好比装修风格，你家是中式风格，他家是美式风格，你总不能说谁好谁坏吧？各有各的喜好，各有各的利弊。这就是文科属性。由与这种属性的存在，总存在撕逼现象，从Unix，Linux，winidows的操作系统到C，C++，Java，golang，JavaScript，Typescript，Python，Lisp的编程语言之争，撕逼无处不在，江湖之大，斗争之激烈，让你会有春秋战国办百家争鸣之感，尤其是一门新的东西出现的时候，一定是踩着一个成名的同行上去的，所谓的diss，碰瓷儿都是刻意的设计。 比如Golang，从设计之初就处处针对现有的主流语言，虽然当时它把自己定义为了操作系统语言，但是最终还是沦为了应用层语言，有GC这种设计本身，就不可能在OS层大放光彩，但是还是这么宣传，你以为语言设计大师们不懂么？他们都是天才级人物，怎么可能这么低级的问题都不懂，但这就是宣传，你一个OS级别的语言，那么快，不论是开发效率还是运行速度都是上乘，在宣传的时候，又增加了一种宣传口号，Google甚至创造了一首歌，来黑Java和Python，达到宣传Golang的目的，虽然Golang在PTL领域被誉为是狗屎一样的语言，基本毫无最新的研究实现，但是在工业领域，不得不说是个奇迹，满足了工业领域 worse is better的新泽西风格，MIT风格再香，不也是没人用么？设计就是这样，满大街的淘宝货，你穿个设计大师的衣服，也就你一个人而已。大众的，未必是好的，但是一定是适合的。工业领域从来都是以经济效益第一，从这点来看，kotlin,golang，JavaScript，一定是最强的语言，但是您非要说是什么科学，是什么品味，那就扯淡了，PTL里面的Haskell和Scala都没说话。所以，经济效益和科学贡献是两码事儿，有的编程语言在学术领域是明珠，在工业领域就是敝履。有的编程语言反之，从设计之初就决定了出身，Scala这种在学术界和工业界都想混一下的语言，最终会越来越小众，就如同真正的设计大师的作品从来没有在历史上泛滥过一样，他们只是榜样作用而已。 我认为递归，逻辑与或判断这些基本思想，背后是公理，就是那种翻译成大白话，人人都能懂得道理，基于这些基本原理和一些科学理论，大师们给我们设计了底层工具，在这些底层工具之上，顶级程序员给我们设计了一些编程语言和框架，以供我们来开发应用，甚至在这些框架和语言之上，有一些顶级程序员基于某一个领域和场景给我们做了特定的设计，让我们能够更简单的开发和设计应用。这就是IT领域的抽象。一层一层之上，不停地抽象，最底层的东西永远是最灵活，但是可能很难用，或者需要大量的知识体系，而IT领域的抽象无非是让大家在资深领域做自己擅长的事儿，OS本身的设计也是这样，内核和驱动的分离，让社区极大地发挥了自身擅长的领域，每个人都可以在擅长的领域基于现有的内核做自己的贡献，感受下这种设计像不像现代社会？一个中央政府，然后不同的部门各司其职，中央政府作为内核负责协调等工作，IT领域里面所谓的单一职责原理，所谓的解耦，模块化设计，其实现实世界比比皆是，大自然更是如此，最强的面向对象设计，无处大自然之右。人类的设计，IT领域的设计，都是对大自然拙劣的模仿加上一些设计的品味和工业界的偏好而已，不要沾沾自喜您的发明创造，大家都是山寨狂魔，山寨无错，更无罪，重要的是发挥自身价值即可。模糊概念，以人为本，文科属性+1 再聊聊软件行业，软件行业是一个很奇怪的行业，拼命把自己往工业界上靠，不断地增加各种方法论，让自己像个工业界，甚至工业界的术语，不停地拿过来，仿佛自己拿过来了自己也和他们一样了，什么精益理论，什么测试驱动开发，什么重构，什么SCRUM，都是工业界玩烂的实践，也不管是否符合自己，反正先拿过来，其实拿来精神本身是很好的，鲁迅先生也说过应该有拿来精神，但是你不分青红皂白，拿来之后，当成了圣旨，不结合自身实际用这个圣旨，大搞整风运动，仿佛谁要是不符合你的测试驱动开发，谁不符合你的理论，就是罪人一般，这就是政治玩法，文科属性+1 前段时间有个很有名的话题：架构师是否一定要写代码，我认为可以不写，甚至不需要写，也不要写。我的论点就是，IT这行是个文科，不是硬科学，领导是可以不知道具体实现的，更重要的是知道什么最重要，知道什么人可用在哪儿，什么技术复合当前业务和现状，做好后期的愿景规划，这就是架构师的职责。既然这样，架构师只是复合学科的人才即可，甚至架构师这几个技能中，你只具备几个，也是可以做的特别好，你在工作的时候是否胜任看你的长处有多长而不是看你的缺点。这点来看大多数行业都是这样，特别是官场更是如此。但是科学领域比较奇怪，你看两弹一星功勋都是大科学家，你看曼哈顿计划，更是人类中的天才。这种最强级别的科学和工业，是人类历史之最，你看看负责人都是什么级别，懂不懂？不懂如何能够指导？可能连名词都不知道，甚至也不知道如何管理。这就是区别，IT领域由与都是人为设计，从一个人的秉性中，就能知道这个人是否靠谱，再加上一些知识就可以评判这个人的大体专业技能。所以一个不懂技术的架构师，也可以很好地评判每个人的水平，只要他还有点管理能力，但是硬科学不行，你一个不懂病毒的人，去搞疫苗，瞎指挥，最后钱花了，事儿没做成，这不行。IT领域不同，协调在这里面特别重要，甚至有的人主要工作就是协调，被戏称为传话筒，传话筒的作用在IT领域重要就是因为它是文科，你让一个传话筒去搞搞原子弹试试？加一个人进来，都会坏事儿。传话筒的存在，专业技能的模糊，文科属性+1. 说了那么多，IT是门文科，不是说文科不好，管理学，经济学都是文科属性极强的学科，但不影响这两门学科是人类极为重要的学科，文科理科工科本身就模糊了界限，但是还是存在谁的属性更强一点，强调IT是文科，只是因为有的人总觉得自己像个科学家，或者像个大师，你不发明东西，你发明的东西，创造的东西，都是基于别人之上的发明，这很好，不丢人，但是在咱们真心不是科学家，别成天拿着概念唬人了，文科的东西不需要概念那么多~","categories":[{"name":"见解","slug":"见解","permalink":"https://ipkaq.com/categories/见解/"}],"tags":[{"name":"见解","slug":"见解","permalink":"https://ipkaq.com/tags/见解/"}]},{"title":"系统设计算法","slug":"系统设计算法","date":"2020-03-22T14:11:20.000Z","updated":"2020-03-27T03:26:55.887Z","comments":true,"path":"2020/03/22/系统设计算法/","link":"","permalink":"https://ipkaq.com/2020/03/22/系统设计算法/","excerpt":"","text":"系统设计算法在系统设计之前你需要知道的算法 布隆过滤器（Bloom filter） Frugal Streaming算法 Geohash算法，Google S2 Geometry算法 漏桶算法（Leaksy Bucket），令牌桶算法（Token bucket） Loosy Counting算法 OT算法（Operational Transformation） 四叉树算法（QuadTree）/R树算法（RTree） 光线投射算法（Ray casting） 倒排索引算法（Reverse index） Rsync算法 Trei树算法 布隆过滤器A Bloom filter is a data structure designed to tell you, rapidly and memory-efficiently, whether an element is present in a set. wiki 布隆过滤器（英语：Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。 基本概念[编辑]如果想判断一个元素是不是在一个集合里，一般想到的是将集合中所有元素保存起来，然后通过比较确定。链表、树、散列表（又叫哈希表，Hash table）等等数据结构都是这种思路。但是随着集合中元素的增加，我们需要的存储空间越来越大。同时检索速度也越来越慢，上述三种结构的检索时间复杂度分别为{\\displaystyle O(n),O(\\log n),O(1)}。 布隆过滤器的原理是，当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在。这就是布隆过滤器的基本思想。 优点相比于其它的数据结构，布隆过滤器在空间和时间方面都有巨大的优势。布隆过滤器存储空间和插入/查询时间都是常数（{\\displaystyle O(k)}）。另外，散列函数相互之间没有关系，方便由硬件并行实现。布隆过滤器不需要存储元素本身，在某些对保密要求非常严格的场合有优势。 布隆过滤器可以表示全集，其它任何数据结构都不能； {\\displaystyle k}和{\\displaystyle m}相同，使用同一组散列函数的两个布隆过滤器的交并[来源请求]运算可以使用位操作进行。 缺点但是布隆过滤器的缺点和优点一样明显。误算率是其中之一。随着存入的元素数量增加，误算率随之增加。但是如果元素数量太少，则使用散列表足矣。 另外，一般情况下不能从布隆过滤器中删除元素。我们很容易想到把位数组变成整数数组，每插入一个元素相应的计数器加1, 这样删除元素时将计数器减掉就可以了。然而要保证安全地删除元素并非如此简单。首先我们必须保证删除的元素的确在布隆过滤器里面。这一点单凭这个过滤器是无法保证的。另外计数器回绕也会造成问题。 在降低误算率方面，有不少工作，使得出现了很多布隆过滤器的变种。 阅读 构建一个爬虫 布隆过滤器的原理实现和优化 什么是布隆过滤器（YouTube视频，讲得很好） 初识布隆过滤器(Bloom Filiter) 拜托，面试官别再问我布隆过滤器了 不了解布隆过滤器？一文给你整的明明白白！ 避免缓存穿透的利器之BloomFilter Frugal Streaming算法Frugal Streaming uses only one unit of memory per group to compute a quantile for each group 阅读 罗格斯大学和Google的论文 Node.js实现Frugal Streaming算法 Geohash / S2 Geometry 算法Geohash can used by dating apps to find romantic matches within a particular cell, and to create chat apps. Find nearby locations, and identify places of interest, restaurants, shops and accommodation establishments in an area. Geohashers go on global expeditions to meet people and explore new places. 阅读 基于DynamoDB和Geohash的LBS结果搜索 高效的多维空间点索引算法 — Geohash 和 Google S2 GeoHash核心原理解析 GeoHash算法详解 周围的餐馆有哪些？GeoHash算法 高效的多维空间点索引算法 — Geohash 和 Google S2 Google S2 是如何解决空间覆盖最优解问题的? 查找 1000 米以内的人，数据库设计和查询如何实现这个功能？ MySQL · 引擎特性 · 初识 MySQL GIS 及 InnoDB R-TREE MySql GIS 空间数据库使用体验 Redis GEO 特性简介 google-s2背后的数学","categories":[{"name":"算法","slug":"算法","permalink":"https://ipkaq.com/categories/算法/"},{"name":"架构","slug":"算法/架构","permalink":"https://ipkaq.com/categories/算法/架构/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://ipkaq.com/tags/算法/"}]},{"title":"论春秋笔法","slug":"论春秋笔法","date":"2020-03-12T12:00:20.000Z","updated":"2020-03-27T03:27:54.907Z","comments":true,"path":"2020/03/12/论春秋笔法/","link":"","permalink":"https://ipkaq.com/2020/03/12/论春秋笔法/","excerpt":"","text":"论春秋笔法《春秋》是孔子编纂，当然在记录历史的时候，暗含褒贬。春秋笔法的意思就是：指行文中虽然不直接阐述对人物和事件的看法，但是却透过细节描写，修辞手法（例如词汇的选取）和材料的筛选，委婉而微妙地表达作者主观看法。原意是指由后世人严格查定前人，看谁是极恶之人、谁尊敬当朝，即所谓“善恶自有历史证明。 在聊春秋笔法之前，我认为需要了解洗脑这个概念，当你一直被灌输某一种观点或者思想的时候，人会陷入一种偏执。所谓的洗脑和时代有关，你不能说王阳明或者张居正也是被洗脑的，他们作为那个时代最理性的人，思维和行为只是受制于时代信息和科学技术发展，如果给他们定义为被洗脑，那么封建社会都是洗脑社会，从一百年后的今天看，今天的人何尝不是被洗脑的呢？如此往复，人人都是被洗脑的，这个词就变得毫无意义。 人作为信息的载体，在接收信息的时候，如果无法理性客观的筛选信息，那么就会沦为被洗脑的工具，所谓的洗脑，就是信息流的获取和处理比较单调，如果你一个直男，天天看LGBT，那么我可以说你在这方面，应该是开放的思维。 说了这么多前缀，和春秋笔法只有一点关系，就是现在社会的媒体等信息流传播渠道，春秋笔法大行其道，媒体对于大众的恶的挖掘，我觉得到了空前的时代，随着信息传播越来越廉价，人人都可以获取，甚至不得不获取这些春秋笔法的狗屎。 举个例子，某媒体报道某一个村子的人吃不饱饭。然后就有人说，什么扶贫都是扯淡，你看现在社会还有吃不饱饭的人，然后公知带一波节奏，找几个图片，然后用一些情感强烈的修饰词，不明情况的时候，很容易被诱导，如果这个吃不饱饭的还是一个孕妇或者儿童，那么这个事儿就一定会更加火爆。但是，这吃不饱饭背后的情景和原因，你不知道，你对于任何事情的评判仅仅限于现有的信息，当这个信息传播渠道把信息掐头去尾的时候，你还能怎么样？ 玩双标，玩春秋笔法，是现在的媒体特色，一些媒体常常打着追求公正理性的旗号，的确，他们的确做过一些公正理性的报道，但是就跟超市卖菜一样，总有便宜的商品，一边引流，另一些利润高的商品，在性价比高商品引来的人流中，总有人人会买这些高利润商品，这本身就是生意，就是商业，无可厚非，商品买卖也是自由的行为，但是，倘若一些媒体，打着为了正义，为了报道不为人知的内幕的旗号，玩弄春秋笔法，你很难发现，你很难时刻辨别，谁天天带着一个警惕性的眼睛来看别人？累不累，我们都是凡人，不可能警惕性那么高，时刻保持那么理性，人一天一直有一两个小时是理性的，剩下的时间更多的思考都是感性动物。感性动物，春秋笔法，完美匹配，媒体赚了人血馒头的钱，你获取了你的信息，得到了内心或者头脑的充实，大家皆大欢喜，长此以往，你感觉自己是个理性的人，是个与众不同的人，别人被洗脑了，你，出淤泥而不染，濯清涟而不妖。你，被春秋笔法成功洗脑。而且是最不好治的那种。 只谈观点不谈方案的是扯淡，所以我提一点自己的见解，如何防止这种行为。 第一：少看带评论性的媒体 第二：不看评论 第三：两手抓，看两种观念或者立场不同的媒体，凡事至少有两面，学过辩证法的人都知道，中国人思维自带辩证法（参看道德经），所以马列在中国行得通。 第四：拉黑制度，不当圣母，该拉黑就拉黑，不仅拉黑个体，媒体，企业都可以被拉黑，很多人，不是突然变坏，也不会突然变好，不要期望会又突然的变化，大而不倒，越是规模化的东西，越不好改变，时间越长的越不好改。这就是为什么大公司病和一些老人特别坏的原因，规模和时间会让缺点更加根深蒂固。 第五：不要获取过多信息，当今天信息大爆炸的时候，我们缺少的不是信息和信息渠道，而是对于信息的自我处理，比如一台计算机，如果仅仅是存储数据，但是不处理数据，这就是一个硬盘而已，硬盘都可以读写，你获取信息却不做处理，不做输出，我认为这种信息是无用的，甚至有害的，它会浪费你的大量精力在上面，当你想拿出精力做有价值的事情的时候，你已经发现自己筋疲力尽甚至被这些新闻带的抑郁寡欢或者张牙舞爪。 以上五点，我觉得自己没有完全做到，做一个理性的人，是个很难的事。理性本身需要知识，信息和知识存在天然的不同，知识自带理性特色，信息更多是为知识服务的，你的知识获取，应该从硬学科获取，或者经历时间考验的载体，而不是新闻，所谓新闻，一定会过时，也可能会耸人听闻，表现得和你有关。借用一句古话，林子大了，什么鸟都有，你管那么多鸟干啥？？？","categories":[{"name":"见解","slug":"见解","permalink":"https://ipkaq.com/categories/见解/"}],"tags":[{"name":"见解","slug":"见解","permalink":"https://ipkaq.com/tags/见解/"}]},{"title":"Akka Streams介绍","slug":"[Akka Streams] 1.Akka Streams介绍","date":"2020-02-23T10:43:41.312Z","updated":"2020-03-27T03:33:38.671Z","comments":true,"path":"2020/02/23/[Akka Streams] 1.Akka Streams介绍/","link":"","permalink":"https://ipkaq.com/2020/02/23/[Akka Streams] 1.Akka Streams介绍/","excerpt":"","text":"Akka Streams介绍动机今天我们从网上消费的服务包含了很多的流式数据的情况，比如从一个服务下载上传，或者点对点的数据交换。把数据看做是流而不是一个整体非常有用，计算机本身就是利用这种方式来收发数据的（例如TCP），经常碰到数据集非常大，此时很难作为一个整体来处理，此时这种做法非常有必要。我们通过集群来分散计算和分析，并且称之为“大数据”，此时处理数据的整体原则是通过多核CPU把数据作为一个流来有序的订阅。 Actor也可以处理流数据：通过发送和接受一系列message来把数据从一个地方转移到另一个地方。我们在发送和接受消息的时候，必须小心处理Streaming Data以避免buffer和mailbox溢出，在Actor之间实现一个稳健的流式系统，此时Actor就有点冗长和易错。Actor还有一个缺陷在于消息可能会丢失，这种情况下必须再次发送。这种发送失败会导致接收端的麻烦。当处理一个具体的指定类型的流式数据的时候，Actor同样不能提供好的静态防护功能避免运行时错误：此时可以利用类型安全来防护。 因为这些原因，我们把整个解决方案捆绑整体作为Akka Stream API。目的是提供一个直观的、安全的流式数据处理的方式，以便我们能够更有效率的处理他们，有界资源的案例—没有内存溢出错误。为了达到这个目的，我们需要能够限制流的速率，当我们的消费服务速度跟不上的时候，系统能够调整生产者生产的速度。这个特性称为背压（back-pressure），这也是Reactive Streams的核心理念之一。对于你来说，复杂的问题和背压机制已经被设计在了Akka Streams中，你需要担心的事情就少了；这同样意味着Akka Stream可以和其他的Reactive Stream 无缝对接交互（Reactive Stream定义了交互[SPI]()，Akka Stream提供了这个实现的用户友好的API） 与Reactive Stream的关系Akka Streams API 和Reactive Streams接口完全解耦。Akka streams专注于数据流的转换形式，而Reactive streams定义了一套通用的机制，如何将数据异步化的，带有缓冲，更好利用资源的搬运数据。 简言之，Reactive Stream的主要目的是为了定义完善的接口，以便不同的流实现可以互操作，而不是定义用户端的API接口定义。所以没有必要花时间来比对Reactive Stream API和Akka Streams API的区别。 如何入门学习Akka Streams的流式处理不同于Acotor模和Future组合，因此可能需要花一些经历来认真学习以下几个主题： 读取快速入门来感受一下Akka Streams看起来是什么，能做什么 自顶向下的学习者可能需要精读Akka Streams背后的设计原则 自底向上的学习者需要通过反复翻看Streams Cookbook来找寻更多的感觉 想要概览整个内置处理操作你需要查看operator index 其他章节可以按照顺序阅读或者当你需要深入某一个的时候按需阅读 参考阅读SPI Wiki SPI Java SPI思想梳理 Java SPI机制详解 高级开发必须理解的Java SPI机制 SPI机制详解 Reactive Stream","categories":[{"name":"Akka","slug":"Akka","permalink":"https://ipkaq.com/categories/Akka/"}],"tags":[{"name":"Akka","slug":"Akka","permalink":"https://ipkaq.com/tags/Akka/"}]},{"title":"不要学习编程，要学习自动化","slug":"不要学习编程，要学习自动化","date":"2019-12-23T13:31:24.000Z","updated":"2020-03-27T03:31:00.085Z","comments":true,"path":"2019/12/23/不要学习编程，要学习自动化/","link":"","permalink":"https://ipkaq.com/2019/12/23/不要学习编程，要学习自动化/","excerpt":"","text":"不要学习编程，要学习自动化Does anyone remember a few years ago, when the mayor of New York decided to learn to program? It was a heady time, because it wasn’t just him. I remember these surreal commercials where Miami Heat forward Chris Bosh was encouraging children to learn to code for the good of humanity or something. There was this sudden, overwhelming sentiment that humanity should abandon the folly of any non-programming pursuit and learn them some Ruby or whatever. Andy Warhol, were he alive in 2012, no doubt would have said, “in the future, everyone will write code for 15 minutes.” Jeff Atwood wrote an interesting rebuttal to this zeitgeist, entitled, “Please Don’t Learn to Code.” The covers a good bit of ground and makes some interesting points, but the overarching thesis seems to be, “avoid thinking of writing code as the goal and learn to solve problems.” I think this is an excellent, philosophical point, but I’d like to add a bit of nuance. I’ve written in the past about how important I think that it is to be a problem solver, to the point where I wrote a post about liking the title “problem solver.” So please don’t think I disagree with his take that a lot of programmers get too hung up with the particulars of code. I don’t — I think that’s a very common issue. But, at the same time, I think the mayor of New York and Chris Bosh and others have a point that Jeff doesn’t really address, per se. Specifically, the world is getting dramatically more technical, which means that a lot of pursuits are being automated out of existence, while other pursuits require an increasing degree of technical savvy. My fiancee, a professional copy editor, is finding aspects of her job to be easier if she knows a bit of HTML and CSS. So while I wince alongside Jeff at the thought of people randomly learning programming languages because they think it’ll make them rich or because they want to be a person that writes lots of code, I don’t think we can simply say, “stay out unless you’re serious and willing to spend years getting good.” The rapidly evolving technical landscape has created this black hole of technical savvy that’s sucking in even people well past the event horizon. The advice that I’d offer on this subject creates a pretty fine distinction. I don’t think that everyone needs to learn to code by any stretch. What I think that everyone needs to start learning about and understanding is how to automate. Or, if not how to do it themselves, at least how to recognize things that could be automated and have meaningful discussions about whether the effort is worth it or not. Automation in Real LifeIt might be best to offer an example here. Tonight, I was working with a friend on some course materials to be communicated via Power Point. We were making slides that were largely images with a few large-font words scattered here and there. We’d paste the pictures into the slide deck, resize a little and then use my Mac’s trackpad laboriously to center the images. At one point, he said, “there should be some shortcut key in Power Point that you can hit and it just auto-centers the thing vertically and horizontally.” That, my friends, is automation at the moment of conception. Centering something on a Power Point is just the kind of brainless, maddening, time-consuming task that makes a good candidate for automation. You know what I’m talking about, where you drag the thing around using movements as microscopic as possible, hoping to see that line appear that indicates that it’s in the middle. It’s so hard to find and you’ve got to go so — wait, there! Crap! Missed it. Back up, try it again. Of course, the conversation doesn’t end here, by any stretch. The talent for which I’m advocating — the talent of savvy automation — involves an assessment like the following, and a potential automation at the end. Does Power Point already provide this capability and we just don’t know about it?Doesn’t seem like it after a bit of quick googling. If it did, a blog about Power Point secrets would probably just need two lines to describe it “Step 1: hit magic key sequence. Step 2: there is no step 2.” But still, it might exist. Is it worth doing more research?Not right now. We’re almost done with the slide deck. On a broader scale, it might be worth doing. Would it be worth it to us over the long haul?Hard to say. I’m not entirely sure how much time in my life is wasted to this problem. It’s probably some but I’m not the most avid Power Point user, so you figure it might take years for it to add up to hours of my time. And who knows how long fixing this problem would take? Would it be worth it for humanity over the long haul?Hmmm… almost certainly. Even if I waste hours on this only after years of Power Point use, humanity probably wastes hours on this after microseconds go by. Lots of people somewhere are swearing at Power Point right this very instant. Could we sell it if we made it?Meh, doubtful. But maybe for a pittance here and there. Or maybe we could just do it, donate it to the greater good, and reap a reputation benefit. Okay, so what’s the next action?Let’s set aside a time box of an hour to research this at a good time for low priority tasks, such as sitting in an airport. A nice interim goal might be to see if we can get it going in a limited scenario. On just a blank slide, does the “ctrl-E” shortcut do the job for horizontal centering? If so, can we find a way to do vertical centering and then somehow chain those shortcuts? If yes, then, bam, problem solved with just a bit of configuration. We’ll know we’ve succeeded when we can hit a single shortcut and have horizontal and vertical center of a single image on a blank slide. If that little test works, we can write a blog post, bask in some win, and then move on to more scenarios. Poor Man’s Coding?Okay, so that was a little hokey, but I’d like to point some things out here. First up was identification of a crappy task and the recognition of an automation candidate. Figuring out the exact coordinates for centering something is the perfect job for a computer. After that came a sequence of questions contemplating the possibility that there might be an existing solution, that coming up with a new one might not be worth it, or that coming up with a new one might be time consuming enough as to offset any gains. In the world of software development, that goes by various names such as “discovery,” “requirements analysis,” and “sprint 0.” After that came a tentative plan of action along with some risk mitigation. Let’s invest a bit of effort in seeing what we can do, but let’s cap that amount of effort so that we don’t run off tilting at windmills. And then there was a concrete strategy that involved carving a larger potential effort down into the smallest slice that might provide some incremental value. This is known in the software development biz as an agile (or, if you want, “lean”) approach to a software project. And then, finally, in spite of the lack of writing of actual code, came implementation and a clear, verifiable description of what success looks like. In the biz, that’s called “Acceptance Test Driven Development” (ATDD). But forget the terms and the parallels to programmer shop-talk. The more important point is that successful software development projects — projects that involve code and IDEs and compilers and whatnot — are just a special case of successful automation projects. You can automate all manner of things, even some very non-trivial things, without actually writing any code. In this vein, Jeff’s point is absolutely spot on. Coders like to code, but writing code ought not to be a first class goal when there are problems to be solved. Throughout human history, there’s been a sort of “pain is gain” approach to the repetitive. There was value in putting your head down, getting into a rhythm, and working hard at menial tasks. But throughout most of that human history, we didn’t have computers. It turns out that computers are really, really good at doing repetitive, menial tasks — tasks that involve precision and not judgment. They’re far better at them than we are, so it makes sense to let computers do them. It’s obtuse to suppose that a prerequisite for every job in the future will be the ability to implement sophisticated, specialized computer applications. But it’s not at all obtuse to suppose that, given the ubiquity of computing, a prerequisite for every job in the future will be the ability to recognize which tasks are better suited for humans and which for computers. Learn at least to recognize which parts of your job are a poor use of your time. After that, perhaps learn to use your ingenuity and creativity to automate using the tools that you know (such as googling for solutions, leveraging apps, etc). And, if you’ve come that far, maybe it’s time to roll up your sleeves and take the plunge into learning to code a little bit to help you along. Because, while there’s no need for the mayor of New York to write any code, it couldn’t hurt him to be ready to jump if something opens up in the city’s IT department.","categories":[{"name":"见解","slug":"见解","permalink":"https://ipkaq.com/categories/见解/"}],"tags":[{"name":"见解","slug":"见解","permalink":"https://ipkaq.com/tags/见解/"}]},{"title":"APM文章收集（持续更新）","slug":"APM 文章","date":"2019-12-22T15:11:20.000Z","updated":"2020-03-27T03:28:52.583Z","comments":true,"path":"2019/12/22/APM 文章/","link":"","permalink":"https://ipkaq.com/2019/12/22/APM 文章/","excerpt":"","text":"APM 文章ES系列 Elasticsearch 可观察性：采用 Prometheus 和 OpenMetrics 标准收集指标 ES APM Java agent文档 ES APM Server 下载地址 [ES APM详细文档地址](https://www.elastic.co/guide/en/apm/get-started","categories":[{"name":"系统设计","slug":"系统设计","permalink":"https://ipkaq.com/categories/系统设计/"}],"tags":[{"name":"APM","slug":"APM","permalink":"https://ipkaq.com/tags/APM/"}]},{"title":"Akka Streams快速指南","slug":"[Akka Streams]2.Akka Streams快速上手","date":"2019-10-22T11:50:06.000Z","updated":"2020-03-27T03:31:54.512Z","comments":true,"path":"2019/10/22/[Akka Streams]2.Akka Streams快速上手/","link":"","permalink":"https://ipkaq.com/2019/10/22/[Akka Streams]2.Akka Streams快速上手/","excerpt":"","text":"Akka Streams快速指南依赖为了使用Akka Streams，添加下面的依赖到项目中 第一步可重用片段基于时间的处理响应式Tweets转换和消费简单的流展开流中的序列广播一个流背压实战物化值","categories":[{"name":"Akka","slug":"Akka","permalink":"https://ipkaq.com/categories/Akka/"}],"tags":[{"name":"Akka","slug":"Akka","permalink":"https://ipkaq.com/tags/Akka/"}]},{"title":"用sentry来改进你的工作流","slug":"用sentry来改进你的工作流","date":"2019-08-22T13:51:03.000Z","updated":"2020-03-27T03:33:27.625Z","comments":true,"path":"2019/08/22/用sentry来改进你的工作流/","link":"","permalink":"https://ipkaq.com/2019/08/22/用sentry来改进你的工作流/","excerpt":"","text":"用sentry来改进你的工作流 如果你是一个开发者，你的工作流可能看起来像下面这样： 设计 —&gt; 代码&amp; review —&gt; 测试 —&gt; CI/CD —&gt; 发现问题 —&gt; 调查 —&gt; 修复 尽管有很多不错的工具可以让开发工作变得容易些，但是这些开发之后的工作流程：发现问题，调查问题，修复问题依然让人痛苦，困惑，烦人，冗长。当你介入一个生产系统bug的时候，你是如何得到的警报？你又是如何评估影响和紧迫性的？你如何快速找到问题的根源？当你提交了修复代码的时候，你如何知道是否解决了问题呢？ 通过集成到您的现有流程中，Sentry帮助您回答这些问题。有了sentry你的工作流可能像下面这样： 123编写代码部署代码发现有一个bug,部署之后，在用户点击点击之后发现是一个NullPointerException异常。sentry立即发现错误，然后通过一些聊天工具或者是一些其他的集成工具来警告你，当然这些告警规则可以在sentry中自定义。 这些提醒信息会带你来到sentry的dashboard，并且给你必要的上下文信息来分类问题，发生频率，用户影响，哪些代码受到影响，哪些团队成员是这个问题的负责人。然后它会给你展示详细信息来帮助你debug问题，例如堆栈跟踪，堆栈本地变量，先前的事件，可能导致问题的代码提交以及错误发生时捕获的自定义数据。您还可以在项目管理工具（如Jira）中自动开始跟踪问题。 确定问题后，将修复代码提交到代码库。现在，你不需要时刻守护着这次fix代码，因为sentry会再代码commit之后，当代码得到部署的时候自动修改这个问题的状态。当这个问题又出现了的时候，sentry会标记这个问题为一个复现问题，并且你又会得到通知告警。 与此同时，当遇到错误的时候，您的网站用户不再需要发给你一个模糊的”你的网站出问题了”来协助你解决问题。但是，值得注意的是，Sentry还可以为这些用户提供一种友好的方式来发送其他信息，这些信息可以帮助您更快地解决问题。 尽管这是工作流的关键，但每个人的配置都有一些不同来以便适配最适合的特定环境。这就是为什么Sentry构造灵活的原因，因此您可以对其进行调整以满足自己的需求。 怎么做？第一步：SDK集成Sentry是一种客户端/服务器体系架构。您将Sentry的SDK集成到您的应用程序中，并开始将错误发送到Sentry的服务器。 根据语言/框架的不同，报告可以是完全自动的，也可以选择发送特定的错误。例如，要自动报告javascript项目中所有未捕获的异常，请将其添加到代码中： 1234Raven.config('&lt;your project specfic key, called a DSN&gt;').install()Raven.context(function () &#123; initMyApp();&#125;); 要捕获特定的错误，您可以添加： 12345try &#123; // Do something that should not raise an exception&#125; catch(e) &#123; Raven.captureException(e)&#125; Sentry开始收到错误后，您将看到如下所示的仪表板： 此处有图 单击一个问题将带您到一个页面，可以帮助您找到根本原因。这里最重要的是堆栈跟踪，显示导致错误的函数调用顺序。对于支持它的语言，您还可以查看单个堆栈框架的局部变量和全局变量的值。 此处有图 接下来是“面包屑”部分，它表示在该错误发生之前发生了的一系列事件。这些事件通常类似于传统日志，但也具有记录更丰富的结构化数据的能力。当sentry和web框架集成的时候，面包屑会自动记录一些事件的日志，比如：数据调用，网络请求，但您也可以手动检测代码中感兴趣的事件，这些事件将出现在后续问题的痕迹中。 此处有图 最后，您还有关于该问题的其他结构化数据： 此处有图 在异常时记录为标签的记录可用作过滤器。这对于确定哪些错误来自特定计算机，浏览器，发行版等很有用。","categories":[{"name":"DevOpts","slug":"DevOpts","permalink":"https://ipkaq.com/categories/DevOpts/"},{"name":"前端","slug":"DevOpts/前端","permalink":"https://ipkaq.com/categories/DevOpts/前端/"}],"tags":[{"name":"DevOpts","slug":"DevOpts","permalink":"https://ipkaq.com/tags/DevOpts/"}]},{"title":"慢就是快 (一)","slug":"慢就是快的理解","date":"2019-07-23T14:17:33.000Z","updated":"2020-03-27T03:22:20.958Z","comments":true,"path":"2019/07/23/慢就是快的理解/","link":"","permalink":"https://ipkaq.com/2019/07/23/慢就是快的理解/","excerpt":"","text":"慢就是快。孙子兵法说：兵贵神速，我说：慢就是快。为了达到目标，我们不免有时候会操之过急，兵贵神速变成了这种浮躁的人的说辞，其实兵贵神速的前提还是一个慢字。“养兵千日用兵一时”，千日慢才能换来一时的快。 任何值得追求的事情，都不能一蹴而就。凡是可以速成的事情，没有一个值得花时间的学习的。走路，吃饭，识字，说话，其实都是非常慢的过程，游泳，驾照，英语，健身，同样没有一个可以速成的。这些技艺类的能力，都是需要持之以恒的拿时间熬出来！那么同样作为技艺的编程，为什么就可以速成呢？ Peter Norvig 在Teach Yourself Programming in Ten Years中说到，编程自学需要十年的时间。十年！假设一天八小时的编程的话，竟然有两万九千多小时！对比那些所谓的一万小时定律的技能，弱爆了。编程本身就是脑力和体力的结合，而且对于我们非英语系国家的人来说，还有迈不开的英语关早晚要过。这都是时间一点点熬出来的。 说了那么多，无非一个意思： 编程是一个花时间的技能！最近我就在反思自己的编程之路，有哪些是真正的花了时间的，有哪些是浅尝辄止的。进行一个大概的时间统计，这个结果令我震惊：大多数的编程类时间都用来：”论坛灌水”，”各种技术博客”，”追逐新技术”，现在回过头来看，所有的这些，带给自己的收益，远小于时间付出。用投资角度来看，这是一门赔本的买卖，而且，赔了这么久，刚发现。所幸不晚，同样用投资的眼光看问题：弥补的措施肯定是选择高收益高回报，低风险的技术投资了。当然这种技术是不存在的，如果用四维象限来看，可能Golang和TypeScript是性价比最高的两门语言，K8s和React是两门值得投入的技术，未来的收益会不错。但是不管如何，不管是php还是Java，亦或是nodejs，golang，甚至是rust这种，大众或者小众都不重要，重要的是，你不能过于分散投资，并且换手率过高，通俗点说就是：别一会儿捣鼓这门技术，一会儿又捣鼓另一门技术。炒股的人，换手率高的，投资品类多的，没有赚钱的。这种上下文切换的消耗，可能比线程间的切换消耗都大，何况你的时间有限。 《佛遗教经》说：制心一处，无事不成，我们在学习任何技能的时候，不免朝三暮四，不免受到各种新的知识的诱惑，不免受到各种生活中的事情干扰。制心一处谈何容易。今天听别人说docker牛逼，就去看docker，明天听别人说微服务是热门，就去看微服务，后天听到人家说AI是未来，就去研究AI，内心浮躁背后，是一种焦虑，也是一种不自信。对自己的选择有着严重的不自信，为什么不能坚信自己的选择是最好的呢？ 技术发展的趋势是，越来越个体化，去中心化是个大趋势，但是所有的去中心化思想的背后，一定会衍生出来另外一种更加庞大的中心化集权，犹如《三国演义》中说的”天下大势合久必分，分久必合”。对于我们来说，我们就要识别出来，变的东西是什么，不变的东西是什么，并且了解自己的性格，是喜欢一直追逐不断革新的技术还是喜欢一些传统稳定深度更强的知识体系呢？其实对于技术难度和技术品味来讲，做前端开发的和做系统底层驱动的没有任何高低之分，不能说搞底层系统驱动的就比搞前端的更牛，但是我们可以说，搞底层系统驱动的开发者，大概率比前端开发者水平高，因为底层系统驱动的入门门槛高，自然会有大量的新手劝退，前端处于军阀混战期间，而且有大量小白教程和培训机构，当然，这都无可厚非，任何的行业繁荣背后都是市场因素，五六年前IOS移动端开发多么炙手可热？技术的热度不代表什么，只要这门技术在行业中有大量的使用，就会有大量的工作机会，而对于个人来看，前端工作多，但是求职者竞争者同样也多，C++驱动开发工作少，但是竞争者同样少。人才市场同样也是市场，符合一切市场规律，物以稀为贵。所以，不能以热门程度来挑选技术，但是也不要挑选过于冷门的技术。 什么技术值得慢慢的深入呢？慢工出细活，其实现在市面上的所有热门技术都值得投入！但是，你需要选一门，只有一门技术来深耕下去。你如果研究一门技术，或者一个领域，你发现其深度的探索过程中，总会有一些瓶颈，这个时候，这些瓶颈就是需要用技术的广度来打开局面，但是，如果一开始就花费大量的时间来看各种书，各种论坛的好坏优劣讨论，看到新技术就去学习，看到别人说什么不好就对自己的选择抱有怀疑，那么就会陷入”程序员的怪圈”中。 很多技术是想通的，但是，你如果研究这门技术没有达到一定深度的时候，你只是一个名词王国的国王罢了，说着各种技术术语的rap也不会让你成为代码界的吴亦凡。用自己身上那些没有思考深度的技术，你会在一年内被各种年轻人超越，最后只能通过自己的”十年工作经验”这种来“震慑”年轻人。 做技术和做人一样，不要急于求成，不要着急看到效果，好汤都是慢慢炖出来的，时间会提升一切技术的质量，如果现在这门技术还缺少想要的理解，如果感觉自己还需要一些技术概念来解释这门技术，那么可能自己还是没有真正掌握这门技术吧。00000000000000000000000000000000000000000000000000000000000000","categories":[{"name":"IT感悟","slug":"IT感悟","permalink":"https://ipkaq.com/categories/IT感悟/"}],"tags":[{"name":"IT感悟","slug":"IT感悟","permalink":"https://ipkaq.com/tags/IT感悟/"}]},{"title":"springcloud gateway系列-快速开始","slug":"springcloud-gateway系列-快速开始","date":"2019-07-12T03:06:37.000Z","updated":"2020-03-27T03:29:28.893Z","comments":true,"path":"2019/07/12/springcloud-gateway系列-快速开始/","link":"","permalink":"https://ipkaq.com/2019/07/12/springcloud-gateway系列-快速开始/","excerpt":"","text":"Springcloud gateway系列-快速开始留坑，待填","categories":[{"name":"springcloud","slug":"springcloud","permalink":"https://ipkaq.com/categories/springcloud/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://ipkaq.com/tags/微服务/"},{"name":"springcloud","slug":"springcloud","permalink":"https://ipkaq.com/tags/springcloud/"}]},{"title":"Kong在docker下安装以及快速使用","slug":"kong在docker下的安装以及快速使用","date":"2018-08-22T01:27:31.000Z","updated":"2020-03-27T03:29:37.803Z","comments":true,"path":"2018/08/22/kong在docker下的安装以及快速使用/","link":"","permalink":"https://ipkaq.com/2018/08/22/kong在docker下的安装以及快速使用/","excerpt":"","text":"API gateway Kong docker安装1. 安装kong和数据库 创建网络 1docker network create kong-net kong数据库 123456789101112docker run -d --name kong-database \\--network=kong-net \\-p 5432:5432 \\-e \"POSTGRES_USER=kong\" \\-e \"POSTGRES_DB=kong\" \\postgres:9.6 数据migrations 123456789101112docker run --rm \\--network=kong-net \\-e \"KONG_DATABASE=postgres\" \\-e \"KONG_PG_HOST=kong-database\" \\-e \"KONG_CASSANDRA_CONTACT_POINTS=kong-database\" \\kong:0.13 kong migrations up Kong启动,开发环境下 123456789101112131415161718192021222324252627282930docker run -d --name kong \\--network=kong-net \\-e \"KONG_DATABASE=postgres\" \\-e \"KONG_PG_HOST=kong-database\" \\-e \"KONG_CASSANDRA_CONTACT_POINTS=kong-database\" \\-e \"KONG_PROXY_ACCESS_LOG=/dev/stdout\" \\-e \"KONG_ADMIN_ACCESS_LOG=/dev/stdout\" \\-e \"KONG_PROXY_ERROR_LOG=/dev/stderr\" \\-e \"KONG_ADMIN_ERROR_LOG=/dev/stderr\" \\-e \"KONG_ADMIN_LISTEN=0.0.0.0:8001, 0.0.0.0:8444 ssl\" \\-p 8000:8000 \\-p 8443:8443 \\-p 8001:8001 \\-p 8444:8444 \\kong:0.13 Kong启动，生产环境下 123456789101112131415161718192021222324252627282930docker run -d --name kong \\--network=kong-net \\-e \"KONG_DATABASE=postgres\" \\-e \"KONG_PG_HOST=kong-database\" \\-e \"KONG_CASSANDRA_CONTACT_POINTS=kong-database\" \\-e \"KONG_PROXY_ACCESS_LOG=/dev/stdout\" \\-e \"KONG_ADMIN_ACCESS_LOG=/dev/stdout\" \\-e \"KONG_PROXY_ERROR_LOG=/dev/stderr\" \\-e \"KONG_ADMIN_ERROR_LOG=/dev/stderr\" \\-e \"KONG_ADMIN_LISTEN=0.0.0.0:8001, 0.0.0.0:8444 ssl\" \\-p 80:8000 \\-p 443:8443 \\-p 8001:8001 \\-p 8444:8444 \\kong:0.13 2. 安装kong dashboard12docker run --rm --network kong-net -p 8888:8080 pgbi/kong- dashboard start --kong-url http://kong:8001 3. 访问dashboard浏览器打开 Dashbord","categories":[{"name":"微服务","slug":"微服务","permalink":"https://ipkaq.com/categories/微服务/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://ipkaq.com/tags/微服务/"},{"name":"kong","slug":"kong","permalink":"https://ipkaq.com/tags/kong/"}]},{"title":"程序员SQL之避免排序","slug":"程序员不可不知的SQL系列之避免排序","date":"2012-11-21T15:03:45.000Z","updated":"2019-07-12T04:26:35.000Z","comments":true,"path":"2012/11/21/程序员不可不知的SQL系列之避免排序/","link":"","permalink":"https://ipkaq.com/2012/11/21/程序员不可不知的SQL系列之避免排序/","excerpt":"","text":"避免排序会进行排序的运算有： 123456GROUP BYORDER BY聚合函数 SUM, COUNT,AVG,MAX,MINDISTINCT集合运算符 UNION INTERSECT EXCEPT窗口函数 RANK ROW_NUMBER 在使用集合运算符的时候，UNION INTERSECT EXCEPT ,如果不在乎结果中有重复数据，请使用UNION ALL代替UNION，这样就不会排序了。对于INTERSECT和EXCEPT都是如此，加上ALL就不会排序了。 使用EXISTS代替DISTINCT，为了去重，DISTINCT也会排序，所以尽可能避免。 在MAX/MIN函数使用时，这两个都会进行排序。如果在参数字段上建有索引，那么只会扫描索引，不会扫描整个表。对于联合索引，只要查询条件是联合索引的第一个字段，索引就是有效的。这种方式并不能去掉排序，只是会优化 通常情况下，GROUP BY 和ORDER BY 都会进行排序。通常优化方式是：采用带有索引的列来进行GROUP BY 和ORDER BY。 在一些数据库里，如果操作对象上的列是唯一索引，那么排序过程本身会被省略掉。","categories":[{"name":"SQL","slug":"SQL","permalink":"https://ipkaq.com/categories/SQL/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://ipkaq.com/tags/SQL/"}]},{"title":"程序员SQL之IN关键词优化","slug":"程序员不可不知的SQL查询优化","date":"2012-11-20T14:05:07.000Z","updated":"2019-07-12T03:08:33.000Z","comments":true,"path":"2012/11/20/程序员不可不知的SQL查询优化/","link":"","permalink":"https://ipkaq.com/2012/11/20/程序员不可不知的SQL查询优化/","excerpt":"","text":"程序员不可不知的SQL系列之谓词 IN 优化当子查询的时候，使用EXISTS替代IN。 IN的使用频率很高，因为语义性很强，很好理解。但是可能成为查询的瓶颈，因为IN是执行的全表扫描，所以一般优化代码中含有IN的语句就能大幅度提高性能。 如果IN是数值列表，那么不需要过多注意，如果是子查询，就要进行优化。 为什么使用EXISTS优化？理由如下： 如果在关联列上建立了索引，那么查询子关联表的时候，不需要查询实际表，只需要查询索引即可。 使用EXISTS，只要查询一行满足条件就会终止查询。 IN是扫描全表。当IN子句是查询的时候，那么数据库会优先执行子查询，并且会将结果存在一张临时表中（内联视图），然后扫描整个视图。这种操作会非常消耗资源。 还有一种方式就是使用连接代替IN,但是大多数情况下EXISTS更好！","categories":[{"name":"SQL","slug":"SQL","permalink":"https://ipkaq.com/categories/SQL/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://ipkaq.com/tags/SQL/"}]},{"title":"如何招聘到优秀的程序员","slug":"百分百招聘到优秀程序员的面试问题","date":"2012-11-18T15:04:19.000Z","updated":"2019-07-12T03:09:47.000Z","comments":true,"path":"2012/11/18/百分百招聘到优秀程序员的面试问题/","link":"","permalink":"https://ipkaq.com/2012/11/18/百分百招聘到优秀程序员的面试问题/","excerpt":"","text":"技术面试诀窍先说诀窍：提出一个问题“在你过去的工作中，遇到过哪些让你印象深刻的困难，你是如何解决的？”，看看对方如何回答。 技术面试最难的是什么大家在招聘中，总是提出各种技术问题，有的很难，有的很简单，不同的面试官的技术方向不同，问题深度和广度也不同，对于应聘者，可能遇到张三就能顺利通过，碰到李四只能被虐。这种没有固定标准，没有固定套路的招聘形式。 靠谱的人按照我的经验来看，简历再漂亮的人，这个问题答不好，大都可以直接忽略！为什么这么说呢？因为我们要招聘的不是一个“经历丰富”的人，而是一个有“职业素养”的人。你遇到的问题有可能会很难，有可能会简单，但是我们看重的并不是问题的难度，而是解决问题的方式、步骤和反思的深度！ 拿恢复误删数据来说，可能算是非常简单的任务。我更感兴趣的是怎么样分析问题，找到了怎样的资料，采取了怎样的步骤，此后做了哪些措施来避免这种错误再次出现。 在我看来，相比问题的难度，解决问题的难度，解决问题的方式和步骤以及反思的深度，都体现一个人的职业素养。 一个所谓的“高手”，可能缺乏这种素养。一个涉世未深的“毛头小子”可能具备这种素养。对于每一个面试官，我觉得你应该反思自己的评判标准是否真的有效！而每一个候选者，需要对自己的过往进行一次反思，哪一次的开发过程给自己的提升最大，自己在这次印象深刻的事件中扮演了什么角色，如何才能更好地发挥自己的能力以及如何提高在团队中的作用！ 总结我一直认为，一个人只有学会了反思才能进步，或许犯错才是进步的唯一途径，这种犯错，印象越深刻，自己的进步动力就越大。反思自己的过往总能给自己一个评判，只有对自己认识深刻，才能认识别人。所以不靠谱的人怎么可能招聘得到靠谱的人呢？ 一直没有说优秀的人？难道靠谱的人不就是优秀的人吗？🙄","categories":[{"name":"IT感悟","slug":"IT感悟","permalink":"https://ipkaq.com/categories/IT感悟/"}],"tags":[{"name":"IT感悟","slug":"IT感悟","permalink":"https://ipkaq.com/tags/IT感悟/"},{"name":"招聘","slug":"招聘","permalink":"https://ipkaq.com/tags/招聘/"}]},{"title":"技术问题最好的讲解方式","slug":"技术问题最好的讲解方式","date":"2012-08-24T13:11:38.000Z","updated":"2019-07-12T03:09:18.000Z","comments":true,"path":"2012/08/24/技术问题最好的讲解方式/","link":"","permalink":"https://ipkaq.com/2012/08/24/技术问题最好的讲解方式/","excerpt":"","text":"我比较喜欢自顶向下的讲解方法： 先了解对外的功能， 再了解各个模块之间的协作， 最后看细节的实现。","categories":[{"name":"IT感悟","slug":"IT感悟","permalink":"https://ipkaq.com/categories/IT感悟/"}],"tags":[{"name":"IT感悟","slug":"IT感悟","permalink":"https://ipkaq.com/tags/IT感悟/"}]},{"title":"程序员的个人成长","slug":"程序员的个人成长","date":"2012-01-01T14:58:36.000Z","updated":"2019-07-12T03:09:08.000Z","comments":true,"path":"2012/01/01/程序员的个人成长/","link":"","permalink":"https://ipkaq.com/2012/01/01/程序员的个人成长/","excerpt":"","text":"个人成长 确立个人方向，结合工作内容，找出对应短板 该领域主要专家们的工作是否都了解？ 相关网络知识，文件格式是否都熟悉？ 相关的技术和主要工具是否看过，用过？ 阅读只是学习过程的起点，不能止于阅读 工具的每个参数每个菜单都要看，要试 学习网络协议要实际抓包分析，学习文件格式要读源码实现 学习老漏洞一定要调试，搞懂别人代码每一个字节的意义，之后要完全自己重写一个Expoit 细节，细节，细节！刨根问底 建立学习参考目标 短期参考什么？比自己优秀的同龄人 阅读他们的文章和其他工作成果，从细节观察他们的学习方式和工作方式 中期参考什么？你的方向上的业内专家 了解他们的成长轨迹，跟踪他们关注的内容 长期参考什么？业内老牌企业和先锋企业 把握行业发展、技术趋势，为未来积累 推荐的学习方式 以工具为线索 一个比较省事儿的学习目录，Kali Linux 学习思路，以Metaspoit为例： 遍历每个目录，除了Expoit里面还有什么？ 每个工具分别有什么功能？原理是什么？涉及哪些知识？ 能否改进优化？能否发展，组合出新的功能？ 以专家为线索 你的技术方向里有哪些专家？ 他们的邮箱、主页、社交网络号是多少？ 他们在该方向上有哪些作品，发表过哪些演讲？ 跟踪关注，一个一个学 处理好学习、工作和生活 学习、学习和工作是矛盾统一的 三者都需要时间，你一天只有24小时 调和矛盾的关键，==提高效率==！ 对没有一个好爸爸的人来说，你的学习、工作会影响你能不能追求诗和远方 有好爸爸也要学习，因为能力之外的资本为零 王思聪：SAT不是满分我们一般都没脸说考过 如何提高效率 做好预研，收集相关前人成果，避免无谓的重复劳动 在可行性判断阶段，能找到工具就不写代码，能用脚本语言写就不用编译语言写，把完美主义放在最终实现阶段 做好笔记并定期整理，遗忘会让所有的投入都白白浪费 多和同事交流，别人说一个工具的名字能让你节约几个小时 咖啡可以提高效率，而且合法 无论如何提高效率，要成为专家，都需要大量的时间投入","categories":[{"name":"IT感悟","slug":"IT感悟","permalink":"https://ipkaq.com/categories/IT感悟/"}],"tags":[{"name":"IT感悟","slug":"IT感悟","permalink":"https://ipkaq.com/tags/IT感悟/"}]}],"categories":[{"name":"见解","slug":"见解","permalink":"https://ipkaq.com/categories/见解/"},{"name":"算法","slug":"算法","permalink":"https://ipkaq.com/categories/算法/"},{"name":"架构","slug":"算法/架构","permalink":"https://ipkaq.com/categories/算法/架构/"},{"name":"Akka","slug":"Akka","permalink":"https://ipkaq.com/categories/Akka/"},{"name":"系统设计","slug":"系统设计","permalink":"https://ipkaq.com/categories/系统设计/"},{"name":"DevOpts","slug":"DevOpts","permalink":"https://ipkaq.com/categories/DevOpts/"},{"name":"前端","slug":"DevOpts/前端","permalink":"https://ipkaq.com/categories/DevOpts/前端/"},{"name":"IT感悟","slug":"IT感悟","permalink":"https://ipkaq.com/categories/IT感悟/"},{"name":"springcloud","slug":"springcloud","permalink":"https://ipkaq.com/categories/springcloud/"},{"name":"微服务","slug":"微服务","permalink":"https://ipkaq.com/categories/微服务/"},{"name":"SQL","slug":"SQL","permalink":"https://ipkaq.com/categories/SQL/"}],"tags":[{"name":"见解","slug":"见解","permalink":"https://ipkaq.com/tags/见解/"},{"name":"算法","slug":"算法","permalink":"https://ipkaq.com/tags/算法/"},{"name":"Akka","slug":"Akka","permalink":"https://ipkaq.com/tags/Akka/"},{"name":"APM","slug":"APM","permalink":"https://ipkaq.com/tags/APM/"},{"name":"DevOpts","slug":"DevOpts","permalink":"https://ipkaq.com/tags/DevOpts/"},{"name":"IT感悟","slug":"IT感悟","permalink":"https://ipkaq.com/tags/IT感悟/"},{"name":"微服务","slug":"微服务","permalink":"https://ipkaq.com/tags/微服务/"},{"name":"springcloud","slug":"springcloud","permalink":"https://ipkaq.com/tags/springcloud/"},{"name":"kong","slug":"kong","permalink":"https://ipkaq.com/tags/kong/"},{"name":"SQL","slug":"SQL","permalink":"https://ipkaq.com/tags/SQL/"},{"name":"招聘","slug":"招聘","permalink":"https://ipkaq.com/tags/招聘/"}]}